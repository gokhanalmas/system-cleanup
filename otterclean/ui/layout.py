import curses
import os
import textwrap

from otterclean.features.browser_cleanup import get_browser_caches, clean_browser_caches
from otterclean.features.secure_delete import secure_delete_file
from otterclean.ui.sections import MenuSection, DetailsSection, FooterSection
from otterclean.ui.ui_components import UIComponents
from otterclean.ui.file_browser import FileBrowser
from otterclean.config.settings import MIN_TERMINAL_WIDTH, MIN_TERMINAL_HEIGHT, COLOR_SCHEME


class LayoutManager:
    def __init__(self, stdscr, options):
        self.stdscr = stdscr
        self.window_height, self.window_width = self.stdscr.getmaxyx()

        menu_height = self.window_height - 3
        menu_width = self.window_width // 3
        details_width = self.window_width - menu_width - 1

        menu_win = stdscr.subwin(menu_height, menu_width, 1, 0)
        details_win = stdscr.subwin(menu_height, details_width, 1, menu_width + 1)
        footer_win = stdscr.subwin(3, self.window_width, self.window_height - 3, 0)

        self.menu_section = MenuSection(menu_win, options)
        self.details_section = DetailsSection(details_win)
        self.footer_section = FooterSection(footer_win)

        self.ui_components = UIComponents()

    def check_terminal_size(self):
        height, width = self.stdscr.getmaxyx()
        if height < MIN_TERMINAL_HEIGHT or width < MIN_TERMINAL_WIDTH:
            raise curses.error(
                f"Terminal window too small. Please resize to at least "
                f"{MIN_TERMINAL_WIDTH}x{MIN_TERMINAL_HEIGHT}."
            )

    def handle_resize(self):
        curses.update_lines_cols()
        new_height, new_width = self.stdscr.getmaxyx()
        if new_height < MIN_TERMINAL_HEIGHT or new_width < MIN_TERMINAL_WIDTH:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, f"Window too small. Minimum size: {MIN_TERMINAL_WIDTH}x{MIN_TERMINAL_HEIGHT}")
            self.stdscr.refresh()
            return

        curses.resizeterm(new_height, new_width)
        self.window_height, self.window_width = new_height, new_width

        menu_height = self.window_height - 3
        menu_width = self.window_width // 3
        details_width = self.window_width - menu_width - 1

        self.menu_section.window.resize(menu_height, menu_width)
        self.details_section.window.resize(menu_height, details_width)
        self.details_section.window.mvwin(1, menu_width + 1)
        self.footer_section.window.resize(3, self.window_width)
        self.footer_section.window.mvwin(self.window_height - 3, 0)

        self.render()

    def render(self):
        self.stdscr.clear()
        self.draw_borders()
        self.menu_section.render()
        details = self.get_details_for_option(self.menu_section.get_selected_option())
        self.details_section.render(details)
        self.footer_section.render()
        self.stdscr.refresh()

    def draw_borders(self):
        self.stdscr.attron(curses.color_pair(COLOR_SCHEME['default']))
        self.stdscr.border()
        self.stdscr.addstr(0, 2, " Otter Clean ")
        self.stdscr.hline(1, 1, curses.ACS_HLINE, self.window_width - 2)
        self.stdscr.addstr(0, self.window_width // 3 + 2, " Operation Details ")
        self.stdscr.vline(1, self.window_width // 3, curses.ACS_VLINE, self.window_height - 3)
        self.stdscr.attroff(curses.color_pair(COLOR_SCHEME['default']))

    def get_details_for_option(self, option):
        details_map = {
            0: "Comprehensive Docker Cleanup: Removes all unused containers, networks, images, and volumes.",
            1: "Remove Unused Docker Images: Deletes Docker images that are not associated with any containers.",
            2: "Remove Stopped Containers: Removes Docker containers that are not currently running.",
            3: "Remove Unused Docker Volumes: Deletes Docker volumes that are not associated with any containers.",
            4: "Clean Docker Build Cache: Removes the build cache used by Docker to speed up image builds.",
            5: "Clean Application Cache: Removes temporary files stored by applications to improve performance.",
            6: "Clean User Logs: Deletes log files generated by user applications.",
            7: "Clean System Logs: Removes system-generated log files.",
            8: "Clean System Cache: Clears system-level cache files.",
            9: "Clean All System Caches: Removes all types of system and application caches.",
            10: "Disk Usage Analysis: Provides a detailed breakdown of disk space usage.",
            11: "Clean Selected Application Caches: Allows you to choose specific application caches to clean.",
            12: "Exit: Close the application."
        }
        return details_map.get(option, "No details available for this option.")


    def display_message(self, message):
        self.ui_components.display_message(self.details_section.window, message)

    def display_result(self, result):
        self.details_section.display_result(result)

    def display_operation_result(self, message):
        self.details_section.display_operation_result(message)

    def display_full_logs(self, result):
        self.details_section.display_full_logs(result)

    def display_operation_message(self, message):
        self.details_section.display_operation_message(message)

    def get_password(self, prompt):
        return self.ui_components.get_password(self.stdscr, prompt)

    def get_password_in_details(self, prompt):
        return self.ui_components.get_password_in_details(self.details_section.window, prompt)

    def select_multiple_options(self, options, prompt):
        return self.ui_components.select_multiple_options(self.details_section.window, options, prompt)

    def display_privacy_options(self, options):
        return self.ui_components.display_privacy_options(self.details_section.window, options)

    def update_privacy_selection(self, options, selected_options, current_selection):
        self.ui_components.update_privacy_selection(self.details_section.window, options, selected_options,
                                                    current_selection)

    def get_file_or_folder(self, prompt):
        return self.ui_components.get_file_or_folder(self.details_section.window, prompt)

    def select_deletion_method(self):
        return self.ui_components.select_deletion_method(self.details_section.window)

    def get_confirmation(self, message):
        return self.ui_components.get_confirmation(self.details_section.window, message)

    def display_error(self, error_message):
        self.ui_components.display_error(self.details_section.window, error_message)

    def display_file_browser(self, prompt):
        current_path = os.path.expanduser("~")
        current_selection = 0
        scroll_offset = 0

        while True:
            self.stdscr.clear()
            self.draw_borders()
            self.menu_section.render()

            max_y, max_x = self.stdscr.getmaxyx()
            split_point = max_x // 3
            details_height = max_y - 5
            max_display = details_height - 2

            self.stdscr.addstr(3, split_point + 2, prompt)
            self.stdscr.addstr(4, split_point + 2, f"Current path: {current_path}")

            items = [".."] + sorted([f for f in os.listdir(current_path) if not f.startswith('.')])
            visible_items = min(max_display, len(items))
            end_index = min(scroll_offset + visible_items, len(items))

            for i, item in enumerate(items[scroll_offset:end_index], start=scroll_offset):
                y = i - scroll_offset + 5
                if i == current_selection:
                    self.stdscr.attron(curses.A_REVERSE)

                item_path = os.path.join(current_path, item)
                if os.path.isdir(item_path):
                    display_text = f"[DIR] {item}"
                else:
                    display_text = f"[FILE] {item}"

                self.stdscr.addstr(y, split_point + 2, display_text[:max_x - split_point - 4])

                if i == current_selection:
                    self.stdscr.attroff(curses.A_REVERSE)

            if len(items) > visible_items:
                scrollbar_height = int(visible_items * (visible_items / len(items)))
                scrollbar_pos = int((scroll_offset / len(items)) * visible_items)
                for i in range(visible_items):
                    if scrollbar_pos <= i < scrollbar_pos + scrollbar_height:
                        self.stdscr.addstr(i + 5, max_x - 1, "█")
                    else:
                        self.stdscr.addstr(i + 5, max_x - 1, "│")

            self.stdscr.addstr(max_y - 2, split_point + 2,
                               "Use ↑↓ to move, ENTER to select/enter directory, 'q' to quit")

            self.stdscr.refresh()

            key = self.stdscr.getch()
            if key == ord('q'):
                return None
            elif key == curses.KEY_UP:
                if current_selection > 0:
                    current_selection -= 1
                    if current_selection < scroll_offset:
                        scroll_offset = max(0, scroll_offset - 1)
            elif key == curses.KEY_DOWN:
                if current_selection < len(items) - 1:
                    current_selection += 1
                    if current_selection >= scroll_offset + visible_items:
                        scroll_offset = min(len(items) - visible_items, scroll_offset + 1)
            elif key == ord('\n'):  # Enter key
                selected = items[current_selection]
                if selected == "..":
                    current_path = os.path.dirname(current_path)
                else:
                    new_path = os.path.join(current_path, selected)
                    if os.path.isdir(new_path):
                        current_path = new_path
                    else:
                        return new_path  # Return the selected file path
                current_selection = 0
                scroll_offset = 0

        return None

    def display_app_caches(self, app_caches):
        selected_options = []
        current_selection = 0
        scroll_offset = 0

        while True:
            self.stdscr.clear()
            self.draw_borders()
            self.menu_section.render()

            max_y, max_x = self.stdscr.getmaxyx()
            split_point = max_x // 3
            details_height = max_y - 5  # Başlık ve alt bilgi için yer bırakıyoruz
            max_display = details_height - 2  # Çerçeve için 2 satır düşüyoruz

            self.stdscr.addstr(3, split_point + 2, "Select Application Caches to Clean:")

            # Görüntülenecek öğeleri sınırla ve kaydırma uygula
            visible_items = min(max_display, len(app_caches))
            end_index = min(scroll_offset + visible_items, len(app_caches))

            for i, (path, size) in enumerate(app_caches[scroll_offset:end_index], start=scroll_offset):
                y = i - scroll_offset + 5
                if i == current_selection:
                    self.stdscr.attron(curses.A_REVERSE)
                marker = 'X' if i in selected_options else ' '
                display_text = f"[{marker}] {os.path.basename(path)}: {size}"
                self.stdscr.addstr(y, split_point + 2, display_text[:max_x - split_point - 4])
                if i == current_selection:
                    self.stdscr.attroff(curses.A_REVERSE)

            # Kaydırma çubuğunu göster
            if len(app_caches) > visible_items:
                scrollbar_height = int(visible_items * (visible_items / len(app_caches)))
                scrollbar_pos = int((scroll_offset / len(app_caches)) * visible_items)
                for i in range(visible_items):
                    if scrollbar_pos <= i < scrollbar_pos + scrollbar_height:
                        self.stdscr.addstr(i + 5, max_x - 1, "█")
                    else:
                        self.stdscr.addstr(i + 5, max_x - 1, "│")

            self.stdscr.addstr(max_y - 2, split_point + 2,
                               "Use ↑↓ to move, SPACE to select/deselect, ENTER to confirm, 'q' to quit")

            self.stdscr.refresh()

            key = self.stdscr.getch()
            if key == ord('q'):
                return None
            elif key == curses.KEY_UP:
                if current_selection > 0:
                    current_selection -= 1
                    if current_selection < scroll_offset:
                        scroll_offset = max(0, scroll_offset - 1)
            elif key == curses.KEY_DOWN:
                if current_selection < len(app_caches) - 1:
                    current_selection += 1
                    if current_selection >= scroll_offset + visible_items:
                        scroll_offset = min(len(app_caches) - visible_items, scroll_offset + 1)
            elif key == ord(' '):
                if current_selection in selected_options:
                    selected_options.remove(current_selection)
                else:
                    selected_options.append(current_selection)
            elif key == ord('\n'):
                break

        return [app_caches[i][0] for i in selected_options]

    def display_deletion_methods(self):
        self.details_section.clear()
        return self.ui_components.select_deletion_method(self.details_section.window)

    def display_operation_interface(self, title, content, footer_text):
        self.details_section.clear()
        max_y, max_x = self.stdscr.getmaxyx()
        split_point = max_x // 3

        # Title
        self.stdscr.addstr(3, split_point + 2, title)

        # Description
        content_lines = content.split('\n')
        for i, line in enumerate(content_lines):
            if 5 + i < max_y - 3:  # Footer için yer bırakıyoruz
                self.stdscr.addstr(5 + i, split_point + 2, line[:max_x - split_point - 4])

        # Footer
        self.stdscr.addstr(max_y - 2, split_point + 2, footer_text[:max_x - split_point - 4])

        self.stdscr.refresh()

    def update_footer_help_text(self, text):
        self.footer_section.set_help_text(text)

    def display_help(self):
        help_text = """
        OtterClean Help:

        Navigation:
        - Use Up/Down arrow keys to move between options
        - Press Enter to select an option
        - Press 'q' to quit the current screen or application

        Options:
        1. Comprehensive Docker Cleanup: Removes all unused Docker resources
        2. Remove Unused Docker Images: Deletes Docker images not in use
        3. Remove Stopped Containers: Removes inactive Docker containers
        4. Remove Unused Docker Volumes: Deletes unused Docker volumes
        5. Clean Docker Build Cache: Clears the Docker build cache
        6. Clean Application Cache: Removes temporary files from applications
        7. Clean User Logs: Deletes user-specific log files
        8. Clean System Logs: Removes system-wide log files
        9. Clean System Cache: Clears system-level cache files
        10. Clean All System Caches: Removes all types of system caches
        11. Disk Usage Analysis: Shows detailed disk space usage
        12. Clean Selected Application Caches: Choose specific app caches to clean
        13. Clean Browser Caches: Clears web browser caches
        14. Secure File Deletion: Securely erases files or folders
        15. Privacy Protection: Removes various privacy-related traces

        Note: Some operations may require administrator privileges.
        Always be cautious when deleting files or cleaning caches.

        Press any key to return to the main menu.
        """
        self.details_section.display_scrollable_text(help_text)

    def display_browser_cache_selection(self):
        browser_caches = get_browser_caches()
        options = [f"{browser} (Estimated size: {clean_func()[1]})" for browser, clean_func in browser_caches]

        selected_options = self.ui_components.select_multiple_options(
            self.details_section.window,
            options,
            "Select browser caches to clean:"
        )

        if selected_options:
            selected_browsers = [browser_caches[i][0] for i in selected_options]
            confirm = self.get_confirmation(f"Are you sure you want to clean the selected browser caches?")
            if confirm:
                result = clean_browser_caches(selected_browsers)
                return result  # Return the result
            else:
                self.display_operation_message("Operation cancelled.")
                return "Operation cancelled."
        else:
            self.display_operation_message("No browser caches selected for cleaning.")
            return "No browser caches selected for cleaning."


    def perform_secure_delete(self, file_path, method):
        total_progress = 100
        for message, progress in secure_delete_file(file_path, method):
            self.footer_section.update_progress(progress, "Secure File Deletion", 0)  # Elapsed time is not calculated here
            self.display_operation_message(message)
        self.footer_section.stop_progress()
        return "File deletion completed"